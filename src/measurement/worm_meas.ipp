#include "worm_meas.hpp"
#include "../moves/worm.hpp"


/*
 * Compute the values of the local trace for worm configurations generated by the following procedure.
 *  Insert copies of the given worm at multiple positions in tau that are generated by
 *      setting taus_ins to the specified time index of the worm.
 * 
 * parameters:
 *   taus_ins: std::vector<double>
 *     Strictly ascending order.
 *     Any element of taus_ins must equal to none of times of the worm except for the one that will be shifted.
 */
template<typename SCALAR, typename SW_TYPE>
std::vector<SW_TYPE::EXTENDED_SCALAR>
compute_trace_worm_ins_tau_shift(
  const operator_container_t &ops,
  const SW_TYPE &sliding_window,
  const Worm &worm_ins,
	int shift_target_time_idx,
  const std::vector<double> &taus_ins
	) {
  std::vector<SW_TYPE::EXTENDED_SCALAR> traces(taus_ins.size());

  // Check validity of taus_ins
  for (auto i=0; i<taus_ins.size()-1; ++i) {
    check_true(taus_ins[i] < taus_ins[i+1], "taus_ins must be in strictly ascending order!")
  }
  for (auto i=0; i < worm_ins.num_independent_times(); ++i) {
    if (i == shift_target_time_idx) {continue;}
    if (std::find(taus_ins.begin(), taus_ins.end(), worm_ins.get_time(i)) != taus_ins.end()) {
      throw std::runtime_error("Invalid taus_ins!")
    }
  }

  // Set up tau_edges
  // The first and last elements must be 0 and beta, respectively.
  std::vector<double> taus_edges;
  auto offset = 0;
  if (taus_ins[0] != 0.0) {
    offset += 1;
    taus_edges.push_back(0.0);
  }
  std::copy(taus_ins.begin(), taus_ins.end(), std::back_insert_iterator(taus_edges));
  if (taus_ins.back() != beta) {
    taus_edges.push_back(beta);
  }

  // Insert worm operators into ops_wrk except for the one that will be shifted.
  auto ops_wrk(ops);
  auto worm_wrk = worm_ins.clone();
  worm_wrk.set_time(shift_target_time_idx, taus_ins[0]);
  for (auto op : worm_wrk.get_operators(exclude_time=taus_ins[0]) {
    ops_wrk.insert(&op);
  }
  auto sw = SW_TYPE(sliding_window.p_model, sliding_window.beta, taus_edges, ops_work);

  for (auto idx_taus_ins=0; idx_taus_inx<taus_ins.size(); ++idx_taus_ins) {
    auto tau = taus_ins[idx_taus_ins];

    // Insert worm operators at tau
    const auto& target_worm_ops = worm_wrk.get_operators_at(tau);
    worm_wrk.set_time(shift_target_time_idx, tau);
    for (const auto& op: target_worm_ops) {
      ops_wrk.insert(*it);
    }

    // Move the both edges to tau and compute trace
    sw.move_edges_to(idx_taus_ins+offset, idx_taus_ins+offset);
    check_true(sw.get_tau_low() == tau);
    traces[idx_taus_ins] = sw.compute_trace(ops_work);

    // Remove worm operators at tau
    for (const auto& op: target_worm_ops) {
      ops_wrk.erace(*it);
    }
  }
}